---
date: 2024-01-23
aliases: piezzo controller
tags: doc, apt-interface
draft: false
---

Les `KPZ101`[^1] sont des contrôleurs de moteur piézoélectrique. Ils peuvent être assimilés à des amplificateurs de tensions contrôlés par ordinateur. Dans notre cas, il sert à contrôler les transducteurs piézo du nanomax, afin de pouvoir effectuer des déplacements 

## Options de configuration

Chaque KPZ se configure via un fichier de configuration `.yaml`[^2] dont voici les options.

> [!info]+
> Nomenclature de la documentation des fichiers de configurations:
> - indique que le champs est obligatoire (sauf indication contraire)
> 1.
> 2.
> 3. Il faut choisir un de ces champs parmi les 3

- `name` : un nom pour le device
- `serial_nm` : le numéro de série du KPZ concerné
	- ex: `"29501986"` (une string de 8 digits commençant par 29)
- `baudrate` :
	- ex: `115200` (default) à choisir parmi les valeur défini par `VALID_BAUDRATES` dans le fichier `__init__.py`
- `out_range` : la valeur maximale de la tension en sortie
	1. `75` (default)
	2. `100`
	3. `150`
- `debug` : active les messages de debug
	1. `true`
	2. `false`
- `mode` : 
	1. `open_loop`
	2. `closed_loop`

voir [[Exemples]] pour des exemples de configurations

### Mode open loop

C'est le mode par défaut, mais il est à proscrire pour réaliser des expériences sérieuses : la reproductibilité des expériences n'est pas envisageable avec ce mode.

Ce mode permet de contrôler la tension appliqué au piézo.

### Mode closed loop

> [!important]+ 
> Le [[KSG101]] doit être bien configuré avant d'utiliser ce mode. Le feedback peut être assuré soit par un cable qui va de la sortie `MONITOR` du [[KSG101]] vers l'entrée `EXT IN` du KPZ, soit par les voix 1 ou 2 du [[KCH601|hub]] (pour plus de détail voir la documentation de celui-ci)

#### Paramètres

- `feedback_in` *string* : La méthode de réception du feedback (voir le callout important plus haut)
	1. `extin`
	2. `chan1` à éviter
	3. `chan2`

## Utilisation du module `KPZ101`

> [!warning] 
> On Linux, you also need to create a udev configuration file to allow user-space processes to access to the FTDI devices. 
> Look [here](https://eblot.github.io/pyftdi/installation.html) to find how to configure udev rules.
> This way, `pyftdi` (the library that run low level communication command) will find all the ftdi chips in kinesis module.
> see [[Installation]]


Je conseil de voir les [[Exemples|exemples]] pour une compréhension rapide de ce module. La documentation suivante est une documentation détaillé de chacune des fonctions de la classe `KPZ101`.

### Méthodes

Les différentes méthodes font intervenir des fonctions bas niveau de la classe [[Device]]. Pour une compréhension fine du module il peut être intéressant d'y faire un tour.

#### `__init__(self, config_file="config_KPZ.yaml") -> None`

Constructeur de la classe. Initialise le dispositif en lisant la configuration à partir d'un fichier YAML spécifié. Par défaut, le fichier de configuration est `config_KPZ.yaml` (il faut indiquer un chemin relatif par rapport au fichier qui a créé une instance de `KPZ101`).

#### `__enter__(self) -> KPZ101`

Méthode de contexte pour entrer dans le contexte d'utilisation du dispositif. Démarre la connexion avec le dispositif, désactive la sortie, configure les entrées/sorties et définit le mode de fonctionnement. Retourne une instance de la classe `KPZ101`.

#### `identify(self) -> bool`

Envoie une commande d'identification au dispositif pour vérifier sa présence. Retourne `True` si la commande est exécutée avec succès, sinon `False`.

#### `set_mode(self) -> None`

Définit le mode de fonctionnement du dispositif. Le mode peut être soit "open_loop" (boucle ouverte) soit "closed_loop" (boucle fermée), en fonction de la configuration.

#### `set_io(self) -> None`

Configure les entrées/sorties du dispositif en fonction des paramètres spécifiés dans la configuration.

#### `set_output_voltage(self, tension: int) -> None`

> Pour l'instant la tension n'est pas spécifié en volt au contraire de ce qu'indique le paragraphe ci dessous. La tension est contrôlé par un entier entre `0` et `32767` qui fait varier la tension entre `0`V et `voltage_limit`V

Définit la tension de sortie du dispositif. La tension est spécifiée en volts. Assurez-vous que le mode est "open_loop" avant d'appeler cette méthode. Si le mode est "closed_loop", une assertion est déclenchée. La tension doit être comprise entre 0 et la limite de tension spécifiée dans la configuration.

#### `set_position(self, pos: int) -> None`

> [!caution]+
> Actuellement il y a un problème avec ce dispositif (bien que le déplacement fonctionne bien) : la spécification du protocol APT n'est pas cohérente avec mes observations (voir [[Mail thorlabs]] et photos).
> Il est donc nécessaire de faire une phase de calibration pour pouvoir être sur que le dispositif aille à la position souhaité

Définit la position du dispositif. Assurez-vous que le mode est "closed_loop" avant d'appeler cette méthode.

#### `enable_output(self) -> None`

Active la sortie du dispositif. Une alerte est imprimée pour avertir de la haute tension.

#### `disable_output(self) -> None`

Désactive la sortie du dispositif.

#### `get_info(self) -> bytes`

Récupère les informations du dispositif, telles que le numéro de série et d'autres détails. Les informations sont retournées sous forme de bytes.

#### `__exit__(self, *exc_info) -> None`

Méthode de contexte pour sortir du contexte d'utilisation du dispositif. Désactive la sortie et termine la connexion avec le dispositif.

### Instanciation

Il existe deux méthode pour instancier une telle classe. Je vais seulement parler de la première car elle est selon moi préférable pour des raisons de sécurité et de propreté du programme.

```python
from apt_interface.KPZ101 import KPZ101
# it is not necessary to import KPZ101Config

# Creation of an instance of KPZ101 and name it x
# This process will automatically call the function __enter__() 
# ie. the connection with the device will be made automatically and the parameters in the file x.yaml will be sent to the device
with KPZ101(config_file="conf/x.yaml") as x:
	# Do stuff with x (call methods)


# The instance x is automatically deleted, no need to do it explicitly
# ie. the connection with the device is closed
```

Si des méthodes utiles ne sont pas implémentés, voir [[Ajouter une fonctionnalité à un appareil préexistant]]

[^1]: https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=2421
[^2]: https://yaml.org/